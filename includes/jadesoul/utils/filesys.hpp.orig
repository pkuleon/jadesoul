#ifndef FILESYS_HPP_1325514009_53
#define FILESYS_HPP_1325514009_53
/**
 * File: filesys.hpp
 * Description: 
 *
 * Copyright (c) 2011 Jadesoul (Home Page: http://jadesoul.org)
 * Licensed under the GNU General Public License:
 * http://www.gnu.org/licenses/gpl.html
 * 
 * Date: 2012-01-02 22:20:09.534000
 * Written In: Peking University, beijing, China
 */

#include "includes.hpp"

// struct Code {
	// Code() {
		// cout<<file<<endl;
	// }
// } code;


/*
文件目录操作

１．创建目录（ＡＰＩ）

BOOL CreateDirectory(LPCTSTR pstrDirName);//pstrDirName是全路径

２．删除目录（ＡＰＩ）

BOOL RemoveDirectory( LPCTSTR lpPathName );

３．判断目录是否存在（Shell Function）

#include <shlwapi.h>
#pragma comment(lib, "shlwapi.lib")   
if (PathIsDirectory(_T("d:\\temp")))
    AfxMessageBox(_T("存在"));
else
    AfxMessageBox(_T("不存在"));
４．取得当前目录（ＡＰＩ）

DWORD GetCurrentDirectory( DWORD nBufferLength, LPTSTR lpBuffer );

５．取得执行文件所在目录（ＡＰＩ）

DWORD GetModuleFileName( HMODULE hModule, LPTSTR lpFilename, DWORD nSize );

６．取得功能目录（Shell Function）

BOOL SHGetSpecialFolderPath( HWND hwndOwner,  LPTSTR lpszPath, int nFolder, BOOL fCreate);

例：读取我的档案目录

    TCHAR szDirFile[1024];
    memset(szDirFile, 0, sizeof(szDirFile));
    BOOL bRet = SHGetSpecialFolderPath(NULL,szDirFile,CSIDL_PERSONAL,true);
    if (bRet)
    {
        AfxMessageBox(szDirFile);
    }
    
    
   1. 一个自认为比较经典的层次文件目录遍历程序

#include <afx.h> 
#include <iostream> 

using namespace std; 

void Recurse(LPCTSTR pstr) 
{ 
   CFileFind finder; 

   // build a string with wildcards 
   CString strWildcard(pstr); 
   strWildcard += _T("//*.*"); 

   // start working for files 
   BOOL bWorking = finder.FindFile(strWildcard); 

   while (bWorking) 
   { 
      bWorking = finder.FindNextFile(); 

      // skip . and .. files; otherwise, we'd 
      // recur infinitely! 

      if (finder.IsDots()) 
         continue; 

      // if it's a directory, recursively search it 

      if (finder.IsDirectory()) 
      { 
         CString str = finder.GetFilePath(); 
         cout << (LPCTSTR) str << endl; 
         Recurse(str); 
      } 
   } 

   finder.Close(); 
} 

void main() 
{ 
   if (!AfxWinInit(GetModuleHandle(NULL), NULL, GetCommandLine(), 0) 
      cout << "panic!" << endl; 
   else 
      Recurse(_T("C:")); 
}

2. 再用CFileFind过程中记住一点:

  在用GetFileName(),GetFilePath()等操作前一定确保有FindNextFile操作。
    没找到，怎么能返回文件信息呢?

3。

C++没有目录操作的支持，需要平台的支持了，比如WINDOWS的MoveFile，FindFirstFile等，建议参看平台的开发文档！
*/


// class file(

#include <windows.h>
#include <stdio.h>
#include <string.h>
#define LEN 1024
// 深度优先递归遍历目录中所有的文件
BOOL  DirectoryList(LPCSTR Path)
{
 WIN32_FIND_DATA FindData;
 HANDLE hError;
 int FileCount = 0;
 char FilePathName[LEN];
 // 构造路径
 char FullPathName[LEN];
 strcpy(FilePathName, Path);
 strcat(FilePathName, "\\*.*");
 hError = FindFirstFile(FilePathName, &FindData);
 if (hError == INVALID_HANDLE_VALUE)
 {
  printf("搜索失败!");
  return 0;
 }
 while(::FindNextFile(hError, &FindData))
 {
  // 过虑.和..
  if (strcmp(FindData.cFileName, ".") == 0 
   || strcmp(FindData.cFileName, "..") == 0 )
  {
   continue;
 }
  
  // 构造完整路径
 wsprintf(FullPathName, "%s\\%s", Path,FindData.cFileName);
FileCount++;
 // 输出本级的文件
 printf("\n%d  %s  ", FileCount, FullPathName);

  if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
  {
   printf("<Dir>");
   DirectoryList(FullPathName);
  }



 }
 return 0;
}

void main()
{
 DirectoryList("D:eclipse-J2EE");
}

#endif /* FILESYS_HPP_1325514009_53 */
