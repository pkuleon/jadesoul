poj 2513 Colored Sticks 【字典树·欧拉回路·并查集】2011-04-07 20:54第一题并查集。因为有case是空的，wa了一次。因为并查集判断都属于一个总集合wa了一次。	并查集判断只有一个集合，是判断他们的子集代表都相等。	这个题目的本质是求是否存在欧拉回路（欧拉轨迹）	定理：设G是连通无向图，则G中存在欧拉轨迹的充要条件是G的度数为奇数的节点个数为0或者2	根据以上这个定义，首先要判断连通性，就要用到并查集，证明G是连通的，然后再判断这些颜色出现的频率即可	Problem: 2513  User:ycdoitMemory: 66352K  Time: 860MSLanguage:C++  Result:Accepted#include<iostream>using namespace std;/*    poj 2513    by YcdoiT【字典树·欧拉回路·并查集】    这个题目的本质是求是否存在欧拉回路（欧拉轨迹）        定理：设G是连通无向图，则G中存在欧拉轨迹的充要条件是G的度数为奇数的节点个数为0或者2    根据以上这个定义，首先要判断连通性，就要用到并查集，证明G是连通的，然后再判断这些颜色出现的频率即可*/const int MaxColor=500000;//-------------------并查集----------------------int Rank[MaxColor],x,y;int v[MaxColor];//初始化 x集合void make_set(int x){	v[x]=x;//    Rank[x]=0;}//查找x 所在的集合int find_set(int x){	if (v[x]!=x) v[x]=find_set(v[x]);           //	return v[x];}//合并x，y所在的集合，用到路径压缩，按秩合并void Union(int x,int y){	x=find_set(x);	y=find_set(y);	if (x==y)    return;	if (Rank[x]>Rank[y]) {		v[y]=x;		++Rank[x];	}	else if (Rank[x]<Rank[y]) {		v[x]=y;		++Rank[y];	}	else if (Rank[x]==Rank[y])    {		v[x]=y;		++Rank[y];	}}//-------------------字典树----------------------int frequency[MaxColor];int colorNum=0;int nodeNum=0;struct trie_node{	trie_node()     {		is_word = false;		for (int i = 0; i<26; ++i)			node[i] = NULL;	}	int index;	bool is_word ; // 根到该节点是否对应一个字符串	trie_node *node[26];};trie_node nodeSet[550000];class Trie{public:	trie_node *root; //根节点	Trie() {		root = NULL;	}	int Insert(const char *str)    //插入	{		if (root == NULL)			root = &nodeSet[nodeNum++];		trie_node *temp = root;		int sl=strlen(str),site;		for (int i = 0; i<sl; ++i)		{			site = str[i] - 'a';			if (temp->node[site] == NULL)    {				temp->node[site] = &nodeSet[nodeNum++];				temp = temp->node[site];			}			else				temp = temp->node[site];		}		if (temp->is_word==true) {			++frequency[temp->index];			return temp->index;		}		temp->is_word = true;		temp->index=colorNum++;		++frequency[temp->index];		return temp->index;	};};int main(){	Trie trie;	char cstr1[11],cstr2[11];	int i,index1,index2,line=5,k;	for (i=0; i<MaxColor; ++i)    make_set(i);	while (scanf("%s %s",cstr1,cstr2)==2) {		index1=trie.Insert(cstr1);		index2=trie.Insert(cstr2);		Union(index1,index2);	}	if (colorNum==0) {		printf("Possible\n");		return 0;	}	k=find_set(0);	for (i=1; i<colorNum && find_set(i)==k; ++i);	if (i!=colorNum)       //不连通		printf("Impossible\n");	else {		k=0;		for (i=0; i<colorNum; ++i)    {			if (frequency[i]%2!=0)    ++k;		}		if (k==0 || k==2)			printf("Possible\n");		else			printf("Impossible\n");	}	return 0;}